MEC - IT PST

Array rotation clock and anti-clock
rotation: 2
original:
    0         1         2      3             4          5          6                                                                              
[Node, Django, Vue, Express, Spring, Flask, Angular, 
    7           8
React, Hibernate]

anti-clock
Vue Express Spring Flask Angular React Hibernate Node Django

clock
React Hibernate Node Django Vue Express Spring Flask Angular



Equilibrium Index:
  0   1  2  3  4   5  6
{-7, 1, 5, 2, -4, 3, 0}	>> 0
               i
eq.index>> 3


0,-3,5,-4,-2,3,1,0
i

totalSum-= i >> 0
when partSum==totalSum
	i
partSum+=i>>



0,-3,5,-4,-2,3,1,0
eq.index>> 0

A chocolate factory is packing chocolates into packets. The chocolate packets here represent an array arrt of N number of integer values. The task is to find the empty packets(0) of chocolate and push it to the end of the conveyor belt(array).
Input:
N = 8
arr = [1, 0, 2, 3, 0, 4, 5, 0]
Output:
[1, 2, 3, 4, 5, 0, 0, 0]

0  1  2  3  4  5  6  7
1, 2, 3, 4, 5, 4, 5, 0
                    i
                               c

c!=0
i=c

Airport security officials confiscated several items of the passengers at the security checkpoint. All the items have been dumped into a huge box (array). Each item possesses a certain amount of risk[0,1,2]. Here, the risk severity of the items represents an array[] of N number of integer values. The task here is to sort the items based on their levels of risk in the array. The risk values range from 0 to 2.
Input:
[1, 0, 2, 2, 1, 1, 2, 2, 1, 0, 2, 1, 0]
Output:
[0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2]


0  1  2  3  4  5  6  7  8  9 10 11 12
1, 0, 2, 2, 1, 1, 2, 2, 1, 0, 2, 1, 0
s						 e
    m

0  1  2  3  4  5  6  7  8  9 10 11 12
0, 1, 2, 2, 1, 1, 2, 2, 1, 0, 2,  1,   0
     s						    e
        m

0  1  2  3  4  5  6  7  8  9 10 11 12
0, 1, 0, 2, 1, 1, 2, 2, 1, 0, 2,  1,   2
     s					      e
        m

0  1  2  3  4  5  6  7  8  9 10 11 12
0, 0, 1, 2, 1, 1, 2, 2, 1, 0, 2,  1,   2
         s				      e	      
             m

0  1  2  3  4  5  6  7  8  9 10 11 12
0, 0, 1, 1, 1, 1, 2, 2, 1, 0, 2,  2,   2
         s				  e	      
                         m

0  1  2  3  4  5  6  7  8  9 10 11 12
0, 0, 1, 1, 1, 1, 0, 2, 1, 2, 2,  2,   2
         s			  e	      
                         m

0  1  2  3  4  5  6  7  8  9 10 11 12
0, 0, 0, 1, 1, 1, 1, 2, 1, 2, 2,  2,   2
             s			  e	      
                             m

0  1  2  3  4  5  6  7  8  9 10 11 12
0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2,  2,   2
             s		     e	      
                             m


Finding missing min element in array
input:
0,1,3,4,5,6,7
output:
2

input:
0,2,3,5,6,7,8
output:
1

input:
0,1,2,3,4,6,7,8,9
output:
5


input:
1,2,3,4,6,7,8,9
output:
0


input:
5,10,8,11
output:
6

input:
98,454,12,86,13,89
output:
87



The Climbing Stairs problem
This is one of the most popular coding problems which can be solved using the Dynamic Programming technique. In this problem, you are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. The question is, in how many distinct ways can you climb to the top?
Note: Given n will be a positive integer.
Example 1:
Input: 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps

Example 2:
Input: 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step.


Example 3:
Input: 5
Output: 8

1+1+1+1+1
2+2+1
1+2+2
2+1+2
1+1+1+2
1+1+2+1
1+2+1+1
2+1+1+1


3

poss>> 4>> 
0 1 2 3
0 1 2 3

step=4
0 1 2 3 4 
0 1 2 3 5

step=5
0 1 2 3 4 5
0 1 2 3 5 8


5
5-1		5-2
4
4-1	4-2>> 2
3
3-1	3-2
2	1>>3

5-1>> 5

3-1	3-2
2	1>> 3



1. Coin Change Problem
You are given an integer array coins representing denominations of coins and an integer amount representing the total amount of money. Your task is to determine the minimum number of coins required to make up the given amount. If it is not possible to make up the amount with the given denominations, return -1.

Constraints:

You can use as many coins of each denomination as needed.

You may assume that there are no negative denominations, and all denominations are distinct.

The input values are positive integers.


Input
coins = [1, 2, 5]  
amount = 11

Output
3

Input
coins = [1, 2, 5]  
amount = 7
Output
2



2. Given N gold wires, each wire has a length associated with it. At a time, only two adjacent small wires are assembled at the end of a large wire and the cost of forming is the sum of their length. Find the minimum cost when all wires are assembled to form a single wire.
Note: using greedy approach
Example:
input:
[1, 1, 6, 6, 7, 8]


[1, 1, 6, 6, 7, 8]
2
[1, 6, 6, 7, 8, 8] 
9
[1, 6, 7, 8, 8, 8]
16 
[1, 7, 8, 8, 8, 8]
24
[1, 8, 8, 8, 8, 8] 
33
[1, 9, 8, 8, 8, 8] 
[1, 9, 8, 8, 8, 8]
Minimum cost to assemble all gold wires: 33



3. Dimond Pattern:
        #
      ##
    ###
  ####
#####
			
    #			
  ###		
#####		
 ###
   #

4. Given an array nums of positive integers of size N. Find all distinct digits present in nums.
Example 1:
Input: nums = [131, 11, 48]
Output: 1 3 4 8
Explanation: 1, 3, 4, and 8 are only distinct
digits that can be extracted from the numbers
of the array.
Example 2:
Input: nums = [111, 222, 333, 4444, 666]
Output: 1 2 3 4 6
Explanation: 1, 2, 3, 4, and 6 are only distinct
digits that can be extracted from the numbers
of the array.

5. Given an array arr[] of positive integers. Your task is to sort them so that the first part of the array contains odd numbers sorted in descending order, and the rest of the portion contains even numbers sorted in ascending order.
Examples:
Input: arr[] = [1, 2, 3, 5, 4, 7, 10]
Output: [7, 5, 3, 1, 2, 4, 10]
Explanation: 7 5 3 1 are odds in descending order and 2 4 10 are evens in ascending order.
Input: arr[] = [0, 4, 5, 3, 7, 2, 1]
Output: [7, 5, 3, 1, 0, 2, 4]
Explanation: 7 5 3 1 are odds in descending order and 0 2 4 are evens in ascending order.



03/01/2025:
1. Given two strings A and B, find if A is a subsequence of B.

Example 1:
Input:
A = AXY 
B = YADXCP
Output: 0 
Explanation: A is not a subsequence of B
as 'Y' appears before 'A'.
 

Example 2:
Input:
A = zac
B = zealoustechcorp
Output: 1
Explanation: A is a subsequence of B.

Example 3:
Input:
A = gksrek
B = geeksforgeeks
Output: 1
Explanation: A is a subsequence of B.

Example 4:
Input:
A = zact
B = zealoustechcorp
Output: 0
Explanation: A is not a subsequence of B.



2. Find the least prime number that can be added with first array element that makes them divisible by second array elements at respective index
Input:
int[] arr1 = {3, 5, 7};
int[] arr2 = {10, 15, 20};
Explanation:
(3 + 7) % 10 == 0, (5 + 5) % 15 == 0, (7 + 13) % 20 == 0
Output:
7 -1 13 
Input:
int[] arr1 = {4, 6, 8};
int[] arr2 = {5, 10, 15};
Output:
-1 -1 7


3. Program to Convert Hexadecimal Number to Binary
Input: Hexadecimal = 1AC5
Output: Binary = 0001101011000101
Explanation:
    Equivalent binary value of 1: 0001
    Equivalent binary value of A: 1010
    Equivalent binary value of C: 1100
    Equivalent binary value of 5: 0101

Input: Hexadecimal = 5D1F
Output: Binary = 0101110100011111



4. Minimum Moves to Convert String
You are given a string s consisting of n characters which are either 'X' or 'O'.
A move is defined as selecting three consecutive characters of s and converting them to 'O'. Note that if a move is applied to the character 'O', it will stay the same.
Return the minimum number of moves required so that all the characters of s are converted to 'O'.
Example 1:
Input: s = "XXX"
Output: 1
Explanation: XXX -> OOO
We select all the 3 characters and convert them in one move.
Example 2:
Input: s = "XXOX"
Output: 2
Explanation: XXOX -> OOOX -> OOOO
We select the first 3 characters in the first move, and convert them to 'O'.
Then we select the last 3 characters and convert them so that the final string contains all 'O's.
Example 3:
Input: s = "OOOO"
Output: 0
Explanation: There are no 'X's in s to convert.

5. You are given an array of size n - 1 that contains distinct integers in the range from 1 to n (inclusive). This array represents a permutation of the integers from 1 to n with one element missing. Your task is to identify and return the missing element.


6. Given an array of stock prices where each element represents the stock price on a specific day, write a function to find the best days to buy and sell the stock such that you achieve the maximum profit. You can only buy and sell the stock once.

45, 12, 3, 10, 50
Best time to buy 3 best time to sell 50

-10, -5, -2, -1, 1
Best time to buy -10 best time to sell 1

90, 40, 20, 10, 4
Best time to buy 10 best time to sell 4





Given an unsorted integer array, print all distinct four elements tuple (quadruplets) in it, having a given sum.

For example,
Input:
A[] = [2, 7, 4, 0, 9, 5, 1, 3]
target = 20
showing quaraplets:
Output: Below are the quadruplets with sum 20
 (0, 4, 7, 9)
(1, 3, 7, 9)
(2, 4, 5, 9)


size = 8, target = 20
[2, 7, 4, 0, 9, 5, 1, 3]

size=7, target=20-3=17		count=1
size=6, target=17-1=16		count=2
size=5, target=11			count=3
size=4, target=2			count=4
size=3, target=2			count=5

size=3, target=2			count=4
size=2, target=-2			count=5

size=2, target=2-4>>-2		count=5>> 4
size=1  target=2-7>>-5		count=6>> 4

size=1 target=2-2>> 0		count=4








Given a stack, sort it using recursion. The use of any other data structures (like containers in STL or Collections in Java) is not allowed.
For example,
Stack before sorting : 5 | -2 | 9 | -7 | 3    where 3 is the top element
Stack after sorting  : -7 | -2 | 3 | 5 | 9    where 9 is the top element




5  -2  9  -7  3

// pop till stack is empty
3
-7
9
-2
5	>> temp

push if stack is empty or current>peek:
	then insert element
otherwise
	pop the peek
	insert current
5>> peek 
-2

-2
5
9>> peek

-2
5
-7>> peek

		9	5	-2	

-7
-2
5
9>> peek

3>> 		9	5	

-7
-2
3
5
9


Jump game VI,
You are given a 0-indexed integer array nums and an integer k.
You are initially standing at index 0. In one move, you can jump at most k steps forward without going outside the boundaries of the array. That is, you can jump from index i to any index in the range [i + 1, min(n - 1, i + k)] inclusive.
You want to reach the last index of the array (index n - 1). Your score is the sum of all nums[j] for each index j you visited in the array.
Return the maximum score you can get.
Example 1:
Input: nums = [1,-1,-2,4,-7,3], k = 2
Output: 7
Explanation: You can choose your jumps forming the subsequence [1,-1,4,3] (underlined above). The sum is 7.
Example 2:
Input: nums = [10,-5,-2,4,0,3], k = 3
Output: 17
Explanation: You can choose your jumps forming the subsequence [10,4,3] (underlined above). The sum is 17.
Example 3:
Input: nums = [1,-5,-20,4,-1,3,-6,-3], k = 2
Output: 0


